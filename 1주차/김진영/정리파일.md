## 1장. 깨끗한 코드

1. `코드`: 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업(=프로그래밍)을 명시한 결과
2. `나쁜 코드`
    - 성능이 나쁜 코드 : 불필요한 연산이 들어가서, 개선의 여지가 있는 코드
    - 의미가 모호한 코드 : 이해하기가 어려운 코드, 네이밍과 그 내용이 다른 코드
    - 중복된 코드: 비슷한 내용인데 중복되는 코드들은 버그를 만든다.
3. `나쁜 코드가 나쁜 이유` : 
    - 나쁜 코드는 계속 나쁜 코드를 만들어지도록 한다.
    - 생산성을 저하시킨다. 즉, 개발속도가 크게 떨어질 수 있다고 볼 수 있다.
    - 나쁜 코드를 개선하기 위해, 새로운 시스템을 만들어야한다. 그러나, 현 시스템을 유지보수하면서 대체할 새로운 시스템 개발하는 것은 현실적으로 어렵다.😥
4. `나쁜 코드를 짜는 이유` :
    - 촉박한 일정 (그러나, 나쁜 코드는 오히려 생산성을 저하하기 때문에 처음부터 차근차근 깨끗한 코드를 만들려는 노력이 필요한 것!)
    - 영향범위가 넓어서 (생각보다 영향범위가 넓어서 건드렸다가, 다른 부분에 버그가 발생할까봐 나쁜 코드를 만들게 된다. 그러나,, 이렇게 만든 코드는 나중에 부메랑처럼 되돌아온다는 것..😂)
5. `클린코드를 정의한 여러가지 대가들의 명언 중 일부`:

    > 깨끗한 코드는 한가지를 제대로 한다 _ 비야네 스트롭스트룹(C++ 창시자)

      : 클래스는 하나의 체계만 담아야 한다! 메서드는 하나의 기능만 담아야 한다!

    > 깨끗한 코드는 단순하고 직접적이며, 잘 쓴 문장처럼 읽힌다 _ 그래디 부치 (객체지향의 대가)

      : 설계자의 의도를 숨기지 않고, 명쾌한 추상화와 단순한 제어문으로!

    ### -> 클린코드란, **성능이 좋은 코드**, **의미가 명확한 코드**, **중복이 제거된 코드** 라고 볼 수 있다. 

6. `보이스카우트 규칙`: " 전보다 더 깨끗한 코드를 만들어야 한다!"


## 2장. 의미있는 이름
1. 변수이름은 의미가 분명하게!

   `ex` 변수명만을 보더라도, 해당 변수를 구현한 코드들을 예상 및 읽는데 효과적이다.
   ```
   (잘못된 변수 설정의 예)                         ------>        (의미가 분명하게 바꿔보면?!)
   int a;                                                        int itemCount;
   String b;                                                     String itemName;
   ```
   
2. 루프 속에 i, j, k 사용하지 않는다! (배열에 담긴 하나하나의 값의 의미를 더 표현하기 위함, 즉 맥락에 맞게 인덱스만을 표기한 ijk보다는 맥락 맞는 이름을 쓴다!)

   `ex` 배열을 순회할 때, index를 의미하는 i를 사용하지 않고 advanced for문 or lamda으로 대체할 수 있다!
   ```
   (ijk 사용)                                ------>       (방법1_advanced for문)                    (방법2_lamda)              
   for (int i=0; i<messages.size(); i++){                  for (String message: messages){           messages.stream().forEach( 
   //                                                       //                                          message -> // ~
   }                                                       }                                         }
   ```

3. 통일성 있는 단어를 사용한다. 프로젝트는 여러명이 협업하여 이뤄지기 때문에 지칭하는 단어에 대해 팀간의 협의로 네이밍 규칙을 정하고 보통 협업에서는 진행

    `ex`
    ```
    Member/Customer/User
    Service/Manager
    Repository/Dao
    ```

4. 변수명에 타입을 넣지 않기

    `ex` 사실, 네이밍이라는 것 자체가 서로의 코드를 더 잘 이해하며 협업을 원할히 또 유지보수에 용이하게 하기 위한 것에 목적이 크다 보니, 
    팀끼리의 클래스/변수 네이밍 규칙에 근거하여 작성하면 된다!
    ```
    String nameString -> name
    Int itemPriceAmount -> itemPrice
    
    Account[] accountArray -> accounts
    List<Account> accountList -> accounts, accountList
    Map<Account> accountMap
    
    public interface IShapeFactory -> ShapeFactory
    public class ShapeFactoryImpl -> CircleFactory
    ```

5. Google Java Naiming Guide

    - Package Naming Guide : All lower case, no underscores

            com.example.deepspace(O)
            com.example.deepSpace(X)
            com.example.deep_space(X)

    - Class Naming Guide : UpperCamelCase

            Character, ImmutableList // 클래스는 명사, 명사구로!
            List, Readable  //인터페이스는 명사, 명사구, (형용사)
            HashTest, HashIntegrationTest  //테스트 클래스는 test로 끝내기

    - Method Naming Guide : LowerCamelCase

            sendMessage, stop //메서드는 동사나 동사구
            pop_emptyStack    //test 대상이 되는 jUnit 테스트에서는 underscore가 사용되기도 한다!


## 3장. 함수
1. SOLID 원칙 (객체지향 설계의 5가지 원칙)
    - `SRP: 단일 책임 원칙`
        - 한 클래스는 하나의 책임만 가져야 한다.
        - 클래스는 하나의 기능만 가지며, 어떤 변화에 의해 클래스를 변경해야하는 이유는 오직 하나 뿐이어야 한다.
        - SRP 책임이 분명하기 때문에, 변경에 의한 연쇄작용에서 자유로워질 수 있다.
        - 가독성과 유지보수가 용이해진다.
        - 실전에서는 쉽지 않으나 늘 상기해야 된다!
     
    - `OCP: 개방-폐쇄 원칙`
        - 소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다.
        - 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 가능한 극대화해야 한다.
        - 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소에는 수정이 일어나지 않고, 기존 구성요소를 쉽게 확장해서 재사용한다.
        - 객체지향의 추상화와 다형성을 활용한다.
        
    - `LSP: 리스코프 치환 원칙`
        - 서브 타입은 언제나 기반 타입으로 교체할 수 있어야한다.
        - 서브 타입은 기반 타입이 약속한 규약(접근제한자, 예외)을 지켜야한다.
        - 클래스 상속, 인터페이스 상속을 이용하여 확장성을 획득한다.
        - 다형성과 확장성을 극대화하기 위해, 인터페이스를 사용하는 것이 더 좋다.
        - 합성(Composition)을 이용할 수도 있다.
        
    - `ISP: 인터페이스 분리 원칙`
        - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
        - 가능한 최소한의 인터페이스만 구현한다.
        - srp는 클래스의 단일 책임, isp는 인터페이스의 단일 책임!
        
    - `DIP: 의존성 역전 원칙`
        - 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다. 추상화는 세부 사항에 의존하면 안된다. 세부사항은 추상화에 따라 달라진다.
        - 하위 모델의 변경이 상위 모듈의 변경을 요구하는 위계 관계를 끊는다.
        - 실제 사용관계는 그대로이지만, 추상화를 매개로 메시지를 주고 받으면서 관계를 느슨하게 만든다.

2. 간결한 함수 작성하기
    - 함수는 되도록 짧게! 하나의 함수에는 하나의 기능만을 구현하도록 개발!
    - 함수 내 추상화 수준을 동일하게 맞추면서 함수를 작게 쪼갠다.
    - 함수는 한가지의 기능만을 수행(srp) 변경에는 닫혀있도록(ocp)
    - 함수 인수에서, 인수의 개수는 0~2개가 적당하다. 3개 이상의 인자에서는, 객체를 인자로 넘기며 인수의 개수를 줄인다..!
   
3. 안전한 함수 만들기
    - 부수효과(side effect)가 없는 함수로 함수와 관계없는 외부 상태를 변화시키지 않는 함수를 말한다.

4. 함수 리팩터링
    - 기능을 구현하는 대략적인 함수를 작성 -> 테스트 코드를 작성 -> 리팩터링
    - 기능을 구현하는 대략적 함수 작성 : 길고, 복잡하고, 중복도 있음
    - 테스트 코드 작성: 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 작성한다.
    - 리팩터링한다: 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고 중복을 제거한다.
    
    
## 느낀점 및 배운점
프로젝트를 하면서 기능구현에만 급급하게 코드를 작성해왔던 현재의 나에서, 조금 더 코드 작성 능력을 기르고자 클린코드에 대한 기존의 개발자 대가들의 생각과 방식들이 무엇인지, 방법은 어떻게 하는 거싱ㄴ지
알고 배워야 한다고 생각하며 이 책 및 스터디를 만들고 참여하고 있다.

지금까지의 협업 프로젝트는 당연히 현업에서의 프로젝트의 규모보다는 작기 때문에 나쁜 코드가 미치는 영향력이 미미하여 경각심이 크게 들지는 않았지만, 이 책을 읽으면서 경각심과 
더 클린한 코드, 다른 사람이 읽기에도 좋은 코드로 바꿀 수 있을지에 대해 고민하는 습관을 꾸준히 생각하고 연습해야 된다고 느꼈다.

책에서의 도입부에서도 저자가 밝혔듯, 이책은 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교, 도구를 소개할 뿐이고 이후의 영역은 나 및 독자의 몫이다.
어떤 일이든 스스로의 노력이나 의지 없이는 어떤 것도 이뤄내거나 성장할 수 없다고 생각하기에.. 처음 지금 책을 읽는 이 시점의 느낌과 의지, 마음가짐으로
꾸준히 좋은 코드, 클린한 코드란 무엇인지 스스로 정의내리고, 고민하는 사소한 이러한 과정들을 연습해가야겠다..! 티끌 모아 태산...! 앞으로도 화이팅..:) 