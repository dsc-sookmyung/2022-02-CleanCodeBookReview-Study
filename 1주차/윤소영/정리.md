## 나쁜 코드
1. 개발 속도를 떨어뜨린다.
2. 생산성을 떨어뜨린다.

## 깨끗한 코드 
- 간단한 논리
- 간단한 추상화 
- 작고 명확한 의존성 
- 명백한 전략에 의한 오류 처리
- 보이는 명확한 의도
- 주의 깊게 짜 손 댈 곳 없는 코드 
- 가독성이 좋은 코드(높은 표현력)
- 적은 중복 
- 테스트 통과 


| 기한을 맞추는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다. 


## 의미 있는 이름
>  이름은 변수, 함수, 인수, 클래스, 패키지 등 많은 곳에 붙는만큼, 이름을 잘 짓는 것은 중요하다.


1. 의도를 분명하게 밝혀라<br>
: 의도가 드러나는 이름은 코드를 이해하기가 쉬워지고, 코드에 대한 이해는 이후 코드를 변경하는 것을 쉽게 할 수 있게 돕는다. 의도가 드러난다는 것은 해당 변수나 함수 등이 어떤 의미를 가지는지, 어떤 일을 수행하는지 등을 말하는 것 같다. 또한, 특정 문화에서만 사용하는 단어나 기발한 이름보다는 의도를 분명하고 솔직하게 표현한 이름이어야 한다.<br>
ex) 리스트의 이름 list1, list2, ... (x)  -> flaggedCells(깃발이 꽂힌 칸을 저장하는 리스트)
2. 그릇된 정보를 피하자 <br>
    - 나름대로 의미를 가지고 널리 쓰이는 단어를 사용하지 않는다.
    - 서로 흡사한 이름을 사용하지 않도록 주의해야 한다.
    - 유사한 개념은 유사한 표기법을 사용해야 한다. <br>
    - 일관성이 떨어지는 표기법은 그릇된 정보다. ex) 대문자 O-숫자 0, 소문자 L-숫자 1

3. 의미 있게 구분하라 <br>
: 읽는 사람이 변수에 함수, 클래스 등의 이름을 보고 어떤 차이가 있는지 알 수 있게 이름을 지어야 한다. 또한, 개념을 구분하지 않은 채 이름만 달리하거나 연속된 숫자를 붙이거나 불용어를 추가하는 것은 좋지 않은 방식이다. 가령 앞서 1번에서 봤던 list1, list2와 같은 이름은 의도가 드러나지도 않으며 아무런 정보를 제공하지 못한다. 
4. 발음하기 쉬운 이름을 사용하라<br>
: 발음하기 쉬운 이름을 작성하면, 소통에 있어서도 원활하다. genymdhms라는 이름의 함수보다 generationTimestamp라는 이름의 함수에 대해 이야기를 나누는 것이 더 쉬운 것을 생각하면 알 수 있는 사실이다. 
5. 검색하기 쉬운 이름을 사용하라<br>
: 변수 이름이 e일 때, 이 변수를 찾기 위해 e를 검색한다면, e가 포함된 단어와 문장이 모두 등장한다. 이는 좋지 못한 선택이다. 이러한 검색 측면에서는 오히려 긴 이름이 짧은 이름보다 좋을 때가 있다. 검색하기 쉬운 이름이란 검색해서 찾고자 하는 것이 바로 나올 수 있는 이름이 아닐까 싶다.
6. 인코딩을 피하라<br>
7. 자신의 기억력을 자랑하지 마라<br>
: 명료함이 최고다! 다른 사람이 이름을 읽고 그 이름에서 그 사람이 아는 다른 이름으로 변환하여 이해해야 한다면, 이름에 개선이 필요하다.
8. 한 개념에 한 단어를 사용하고 말장난을 하지 마라<br>
: 매개변수로 두 값을 전달받아 더한 값을 리턴하는 함수를 add라고 했을 때, 집합에 값 하나를 추가하는 기능을 수행하는 함수를 add라고 하기에는 맥락이 다르다. append 등 다른 이름을 사용해야 한다. 
9. 상황에 맞게 해법 영역, 문제 영역 중 하나의 영역에서 가져온 이름을 사용하라<br>
: 모든 이름을 문제 영역에서 가져오는 것은 아니다. 해법 영역에서 가져와 사용할 수 있다면 하고, 또 문제 영역과 연관이 깊고 해법 영역에서 가져와 사용할 단어가 없다면, 문제 영역에서 이름을 가져와 사용할 수 있어야 한다. 
10. 불필요한 맥락을 없애라<br>
: 일반적으로 의미가 분명한 경우에 한해서는 이름이 긴 것보다는 짧은 것이 좋다. 하지만, 이름이 길어질 때도 있다. 가령 클래스의 이름으로는 Address가 적합하지만, accountAddress, customerAddress와 같은 이름은 클래스보다는 인스턴스 이름에 적합하다. 이렇게 각 의미를 분명히 해주기 위해서는 이름이 길어질 때도 있는 것이다. 

- 클래스, 객체 이름은 명사나 명사구가 적합하다. 같은 단어는 피하고 동사는 사용하지 않는다.
- 메소드 이름은 동사나 동사구가 적합하다. 단, 접근자, 변경자, 조건자는 javabean 표준에 따라 앞에 get, set, is를 붙인다.

## 함수 
| 어떤 프로그램이든 가장 기본적인 단위는 함수이다. 
1. 작게 만들어라<br>
: if 문, else 문, while 문 등에 들어가는 블록이 한 줄, 즉, 함수에서 들여쓰기는 1~2단을 넘어서면 안 된다. 함수도 읽고 이해하기 쉬운 것이 좋기 때문이다. 
2. 하나의 함수는 하나의 기능을 수행해야 한다.<br>
: 깨끗한 코드가 무엇인지에 대한 내용을 읽을 때도 봤던 것인데, 함수는 하나의 기능을 해야 한다. 부수 효과를 일으키는 함수보다는 명확하게 하나의 기능을 수행하는 함수가 좋다. 부수 효과를 일으키면 의도하지 않은 혼란을 발생시킬 수 있다. 하나의 기능을 구별하기가 쉽지 않은데, 하나의 기능을 판단하는 방법으로는 그 함수에서 단순히 다른 표현의 이름으로 나타내는 것 말고, 의미가 있는 이름으로 다른 함수를 추출할 수 있는지 확인해보는 것이다. 
3. 명령과 조회를 분리하라<br>
: username인 속성을 찾아 값을 unclebob으로 설정한 후 성공하면 true를, 실패하면 false를 반환하는 함수 set이 있으면 if(set("username", "unclebob"))와 같이 의미가 모호한 코드를 작성하게 된다. 이 함수에서는 속성을 찾는 것과 값을 설정하는, 조회와 명령이 함께 존재한다. 조회와 명령을 attributeExists와 setAttribute 이름의 함수로 나누어주면, if(attributeExists("username")) { setAttribute("username", "unclebob") } 와 같이 작성하여 혼란을 해결할 수 있다. 
4. switch 문은 상속 관계를 이용해 숨긴다. 
5. 서술적인 이름으로 함수의 기능을 잘 나타내도록 한다.<br>
: 이뿐만 아니라, 같은 모듈에 존재하는 함수 이름에 같은 문구 명사, 동사를 사용하는 일관성을 가지면 좋다. 
6. 함수 인수<br>
: 함수에서 이상적인 인수 개수는 0개, 즉, 무항이다. 그 다음으로는 1항, 2항, 3항인데, 3항은 피하는 것이 좋다고 하다. 사실 이 부분을 보고 MIPS 레지스터가 떠올랐는데, 수업시간에 함수 인자를 저장하는 레지스터의 개수가 4개라고 배울 때는 4개보다 더 많은 인자를 가진 함수는 어떻게 하나 생각했기 때문이다.. 하지만, 함수 인수는 적을수록 좋다는 사실을 알고 나니 이해가 되는 개수이다. 만약, 함수의 인수가 2-3개 필요할 때는 해당 인수를 클래스 변수로 선언해 묶을 수 있는지 확인해보는 것도 좋다. 가령, x, y 좌표를 의미하는 double x, double y를 전달할 때는 Point 클래스에 변수 x, y를 묶어 인자로 Point 인스턴스를 넘기는 것이다. 
7. 중복을 제거해야 한다.<br>
: 중복 제거는 함수에서만이 아니라, 소프트웨어의 많은 곳에서 중요하게 다뤄진다. 관계형 데이터베이스의 정규 형식, 객체지향 프로그래밍, AOP, COP를 떠올려도 알 수 있듯이 말이다. 중복이 존재하면 코드를 수정할 때도 불편해지고, 어느 한 곳을 빠뜨렸을 때 오류가 발생할 확률도 높아질 뿐만 아니라, 가독성을 위해서는 중복 제거가 효과적이다. 


### SRP(Single Responsibility Principle)
> 객체 지향 5애 원칙 중 하나로, 단일 책임 원칙인 SRP는 한 클래스는 하나의 책임만 져야 한다를 의미하는 간단한 규칙이다. 

- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. 
- 하나의 속성이 여러 의미를 가지면 이는 SRP를 위반한 것이다. 

### OCP(Open Closed Principle)
> 객체 지향 5애 원칙 중 하나로, 개방-폐쇠 원칙인 OCP는 함수, 클래스, 모듈 등의 소프트웨어 객체는 확장에 대해 열려 있고 수정에 대해 닫혀 있어야 한다는 프로그래밍 원칙이다.

- 확장에 대해 열려 있다는 것은 어떤 요구 사항이 변경되었을 때, 모듈의 동작을 확장할 수 있다는 것, 모듈이 하는 일을 변경할 수 있다는 것이다. 
