# 8장. 경계

## 1. 경계란?
- 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다.
- 외부 코드는 외부시스템과 호출하거나 단순히 외부에서 만들어진 코드일 수 있다. 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야 한다.

## 2. 경계 짓는 방법
- 캡슐화: 객체의 실제 구현을 외부로부터 감추는 방식
  - 외부에 노출되는 method는 public으로, 내부의 data나 method는 private로

- 외부 코드와 호환하기: 외부 코드를 호출할 때, 우리가 원하는 방식으로 사용하고 싶다!
  - adapter 패턴: 외부 코드를 호출할 때, 우리가 정의한 인터페이스대로 호출하기 위해 사용하는 패턴

- learning test를 작성해, 라이브러리를 테스트한다.
  - learning test 작성시, 장점
     - learning test는 이해도를 높인다.
     - 외부 코드의 버전이 변경되었을 때, 우리 코드와 호환되는지 확인할 수 있다.


# 9장. 깨끗한 테스트 코드
## 1. 테스트 코드의 중요성
테스트 코드는 실수를 바로 잡아주기 때문에 반드시 존재해야하며, 실제 코드 못지 않게 중요하다.
테스트 케이스는 변경이 쉽도록해야 하며, 코드에 유연성/유지보수/재사용성을 제공하는 버팀목이 단위테스트이다.

<Effective Unit Test> 책에서는 테스트 실사용에 적합한 설계를 끌어내준다. 테스트 작성해서 얻게 되는 큰 수확은 작성 과정에서 얻는 깨달음이다! 라고 테스트 중요성을 말하고 있다.

테스트는 자동화되어야한다.

## 2. 테스트의 종류
- Test Pyramid: Unit<Integration<E2E
  - Unit test: 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다. 배포하기전, 자동으로 실행되도록 많이 사용한다.
  - Integration test: 프로그램 내부의 개별 컴포넌트들을 합쳐서 동작을 테스트한다.
  - E2E test: End to End test로 실제 유저의 시나리오대로 네트워크를 통해 서버의 end point를 호출하여 테스트한다.

## 3. Unit test 작성
- 테스트 라이브러리를 사용한다. (ex. Junit, mockito)
- test double: 테스트에서 원본 객체를 대신하는 객체
  - stub: 원래 구현을 최대한  단순한 것으로 대체한다. 테스트를 위해 프로그래밍된 항목에만 응답한다. (상태검증)
  - spy: stub의 역할을 하면서, 호출에 대한 정보를 기록한다. 이메일 서비스에서 메시지가 몇번 전송되었는지 확인할 때 사용한다.
  - mock: 행위를 검증하기 위해, 가짜 객체를 만들어 테스트한다. 호출에 대한 동작을 프로그래밍 할 수 있다. (행위검증)

## 4. First 원칙
- fast: 테스트는 빨리 돌아야 한다. 자주 돌려야 하기 때문이다.
- independent: 각 테스트는 독립적으로 작성한다. 서로에게 의존하면 실패한 원인을 찾기 어려워진다.
- repeatable: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제환경, QA 환경, 모든환경에서 돌아가야 한다.
- self-validation: 테스트는 bool값으로 결과를 내야 한다.
- timely: 테스트하려는 실제 코드를 구현하기 직전에 구현한다.








